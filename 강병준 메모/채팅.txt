채팅기능에대한 메모 및 일정관리 .


암호화 및 HTTPS 암호화


Chatting Room 엔티티 클래스 (테이블) 와 

ChatMessage (채팅메세지) 엔티티 클래스(테이블) 두가지를 생성 
ChatMessage 는 Chatting Room 테이블과 manyToOne 으로 설정되어있을것이고 ChattingRoom 테이블은 User 와manyToOne 관계를 갖고있을것이다 .

chatmessge는 여러개의 메세지들이 하나의 채팅방에 귀속되어있을것이고 , 

채팅방은 여러개의 채팅방이 각 채팅을 주고받은 유저에 귀속되어있을것이다 .


1:1 채팅방에서 필요한 기능 .


클라이언트 : 게시물 하단 채팅하기버튼을 누른다( 빌리고싶은사람 ( 채팅메세지엔티티에선 sender가 될것이고 채팅룸 엔티티에서는 borrower 가 될것이다 , )) ,
채팅하기버튼을 누르고 하나의 메세지를 보내면 챗룸 엔티티가 최초로 생성되고 , 하나의 메세지당 하나의 엔티티가 생성될것이다 , 그엔티티는 챗룸에 귀속되어있다 (mappedBy = ChatRoom)

사용자는 어떤 한 게시물에대해서 거래를 위해서 채팅방을 생성 및 대화를 시도할것이기떄문에 일단 이부분에 대한 개발이 먼저 필요하다. 


*** 
HTTP 와 WebSocket에 대한 연결방식과 데이터흐름 차이 

HTTP 는 클라이언트가 요청 -> 서버 응답반환 : 단방향 (request - response) 구조 이다 .
매번 새로운 요청마다 새로운 연결이 생성되고 응답 후 연결이 종료된다 .
서버가 클라이언트에게 능동적으로 메세지를 보낼 수 없다 .(클라이언트가 지속적으로 "새 메세지가 있나요  ? " 하고 물어봐야함 (polling (폴링은 리얼타임 웹을 위한 기법으로, 일정한 주기(특정한 시간)을 가지고 서버와 응답을 주고 받는 방식을 말한다)))

WebSocket

최초 한번 HTTP 업그레이드(handShake) 로 연결을 맺은뒤 , 지속적이고 양방향(Full-Duplex) 통신이 가능하다 .
서버와 클라이언트가 언제든 자유롭게 데이터를 주고받을 수 있다 .
서버가 클라이언트에게 즉시 메세지를 푸시할수있어 실시간성이 매우 뛰어나다 .
연결이 유지되는동안 추가적인 연결/해제 과정이 없으므로 오버헤드가 적고 , 지연이 매우낮다 . 

연결이 시작되는순간과 연결이 종료되는순간 

시작 : 
클라이언트가 서버에 WebSocket 연결을 요청할때 먼저 HTTP 요청을 보내고 
서버가 이를 WebSocket 프로토콜로 업그레이드(HandShake) 하면 연결이 성립된다 .
이 과정에서 HTTP 헤더에 Upgrade: webscoket 이 포함되어있고 
서버가 이를 수락하면 지속적은 양방향 통신채널이 열린다 .

종료 :
클라이언트 또는 서버가 명시적으로 연결종료(close) 를 요청할 수 있다 .
클라이언트에서 socket.close() 호출 , 서버에서 연결 종료 신호전송 등
네트워크 문제 , 서버다운 ,타임아웃 등으로 연결이 비정상적으로 끊길 수 있다 .
연경종료는 Websocket 프로토콜의 closing handshake 에 따라 처리된다 .
한쪽이 종료요청을 보내면 상대방이 이를 수락하고 , 최종적으로 TCP 연결이 닫히면서 완전히 종료된다 .
비활성 (예 : 장시간 메시지 미전송) 시 프록시 , 방화벽 , 서버설정에 따라 자동으로 연결이 끊길 수 있다 .
(예 : 60초 이상 아무데이터도 오가지않으면 연결종료 )

webSocket 연결의 라이프사이클(생명주기) 요약
1 handShake : HTTP 요청 / 응답으로 시작 , upgrade : websocket 헤더로 프로토콜 전환 
2. conntetion Opened :  서버가 수락하면 연결성립 , 양방향 통신 시작 
3. Data transmission : 연결이 유지되는동안 자유롭게 메세지 송수신 
4. Close Connection : 클라이언트/ 서버가 종료요청 -> closing handshake -> 연결종료 이벤트 발생 

Spring WebSocketHandler에서는

afterConnectionEstablished(WebSocketSession session) : 연결 시작 시 호출

afterConnectionClosed(WebSocketSession session, CloseStatus status) : 연결 종료 시 호출

정리 : WebSocket 연결은 handshake 가 완료되는 순간 시작되고 , 클라이언트 / 서버의 종료요청 , 네트워크문제 , 타임이ㅏ웃 등으로 closing handshake 가 완료되는 순간 종료된다 .
이 모든과정은 websokcet 프로토콜( RFC 6455) 에 의해 표준화되어있다 .

WebSocket은 서버와 클라이언트가 한 번 연결하면, 실시간으로 자유롭게 데이터를 주고받을 수 있어
채팅, 실시간 알림 등에는 필수적이고 , HTTP 는 요청-응답이 반복되는 구조라 실시간성이 떨어지며 , 서버푸시가 불가능하다 .
실시간성이 중요하다면 Wensocket , 단순 데이터 조회/등록은 HTTP 를 사용하는 이유이다 ..
***

ChatHandler와 RestController 는 각각 채팅에대해서 담당하는부분이다르다 .

그간 우리가 사용해왔던 방식에서는 HTTP 통신을통해서 서버와 클라이언트에서 클라이언트의 요청-> 서버의 응답 이런식으로  단방향 통신을통해 데이터를 저장하고 응답을 반환하는 로직이였으나 
WebSocket 통신을 사용하게된다면 통신이 끊어지지않는상태에서 서버와 클라이언트가 통신을하게된다 .
사용자간의 대화가 하나씩 생긴다면 ChatHandler에서 Json객체의 메세지를받아 DTO로변환 -> service 메서드를 호출하여 DB에 저장하게하는 실시간으로 주고받는 메세지를 담당하는 Contorller이고 
사용자의 대화방에대한 조회 , 사용자가 대화방에 들어갔을때 주고받았던 대화를 조회하는 HTTP 통신을 사용하는 Controller의 분리가 필요하다 .

여기서 websocket 통신을 사용했을때 끊어지지않는 통신에서 연결되어있는쪽은 user1과 user2 가 서로 대화를 하고있다고 가정했을때  user1- 서버 user2 -서버이고 ,  user1이 작성한메세지를 user2 는 
별도의 HTTP 통신을 이용하지않아도 실시간으로 서버에서 반환되는(DB에 저장되어있는 user1,user2 의메세지) 즉시 렌더링이 가능하다 .


1: 게시글의 채팅하기 버튼을 누르고 메세지를 보내며 websocket 통신 시작 .
	postIdx와 채팅하기 버튼을 누른 빌리려는사람(borrower) 의 userId를 전송
	postIdx를 통해 lender(빌려주는사람 의 userEntity.idx)  @AuthenticationPrincipal String userId 매개변수를 통해서 인증객체(빌리려는사람 , borrower) 의  userId를통해 (userEntity.idx) 를 조회후
	두 사용자간의 채팅방이 있는없는지 검증 , 있다면 websokcet 연결 없다면 채팅방 생성로직 진행 후 webscoket 연결 
	







