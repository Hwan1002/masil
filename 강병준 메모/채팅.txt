채팅기능에대한 메모 및 일정관리 .


암호화 및 HTTPS 암호화


Chatting Room 엔티티 클래스 (테이블) 와 

ChatMessage (채팅메세지) 엔티티 클래스(테이블) 두가지를 생성 
ChatMessage 는 Chatting Room 테이블과 manyToOne 으로 설정되어있을것이고 ChattingRoom 테이블은 User 와manyToOne 관계를 갖고있을것이다 .

chatmessge는 여러개의 메세지들이 하나의 채팅방에 귀속되어있을것이고 , 

채팅방은 여러개의 채팅방이 각 채팅을 주고받은 유저에 귀속되어있을것이다 .


1:1 채팅방에서 필요한 기능 .


클라이언트 : 게시물 하단 채팅하기버튼을 누른다( 빌리고싶은사람 ( 채팅메세지엔티티에선 sender가 될것이고 채팅룸 엔티티에서는 borrower 가 될것이다 , )) ,
채팅하기버튼을 누르고 하나의 메세지를 보내면 챗룸 엔티티가 최초로 생성되고 , 하나의 메세지당 하나의 엔티티가 생성될것이다 , 그엔티티는 챗룸에 귀속되어있다 (mappedBy = ChatRoom)

사용자는 어떤 한 게시물에대해서 거래를 위해서 채팅방을 생성 및 대화를 시도할것이기떄문에 일단 이부분에 대한 개발이 먼저 필요하다. 


*** 
HTTP 와 WebSocket에 대한 연결방식과 데이터흐름 차이 

HTTP 는 클라이언트가 요청 -> 서버 응답반환 : 단방향 (request - response) 구조 이다 .
매번 새로운 요청마다 새로운 연결이 생성되고 응답 후 연결이 종료된다 .
서버가 클라이언트에게 능동적으로 메세지를 보낼 수 없다 .(클라이언트가 지속적으로 "새 메세지가 있나요  ? " 하고 물어봐야함 (polling (폴링은 리얼타임 웹을 위한 기법으로, 일정한 주기(특정한 시간)을 가지고 서버와 응답을 주고 받는 방식을 말한다)))

WebSocket

최초 한번 HTTP 업그레이드(handShake) 로 연결을 맺은뒤 , 지속적이고 양방향(Full-Duplex) 통신이 가능하다 .
서버와 클라이언트가 언제든 자유롭게 데이터를 주고받을 수 있다 .
서버가 클라이언트에게 즉시 메세지를 푸시할수있어 실시간성이 매우 뛰어나다 .
연결이 유지되는동안 추가적인 연결/해제 과정이 없으므로 오버헤드가 적고 , 지연이 매우낮다 . 

연결이 시작되는순간과 연결이 종료되는순간 

시작 : 
클라이언트가 서버에 WebSocket 연결을 요청할때 먼저 HTTP 요청을 보내고 
서버가 이를 WebSocket 프로토콜로 업그레이드(HandShake) 하면 연결이 성립된다 .
이 과정에서 HTTP 헤더에 Upgrade: webscoket 이 포함되어있고 
서버가 이를 수락하면 지속적은 양방향 통신채널이 열린다 .

종료 :
클라이언트 또는 서버가 명시적으로 연결종료(close) 를 요청할 수 있다 .
클라이언트에서 socket.close() 호출 , 서버에서 연결 종료 신호전송 등
네트워크 문제 , 서버다운 ,타임아웃 등으로 연결이 비정상적으로 끊길 수 있다 .
연경종료는 Websocket 프로토콜의 closing handshake 에 따라 처리된다 .
한쪽이 종료요청을 보내면 상대방이 이를 수락하고 , 최종적으로 TCP 연결이 닫히면서 완전히 종료된다 .
비활성 (예 : 장시간 메시지 미전송) 시 프록시 , 방화벽 , 서버설정에 따라 자동으로 연결이 끊길 수 있다 .
(예 : 60초 이상 아무데이터도 오가지않으면 연결종료 )

webSocket 연결의 라이프사이클(생명주기) 요약
1 handShake : HTTP 요청 / 응답으로 시작 , upgrade : websocket 헤더로 프로토콜 전환 
2. conntetion Opened :  서버가 수락하면 연결성립 , 양방향 통신 시작 
3. Data transmission : 연결이 유지되는동안 자유롭게 메세지 송수신 
4. Close Connection : 클라이언트/ 서버가 종료요청 -> closing handshake -> 연결종료 이벤트 발생 

Spring WebSocketHandler에서는

afterConnectionEstablished(WebSocketSession session) : 연결 시작 시 호출

afterConnectionClosed(WebSocketSession session, CloseStatus status) : 연결 종료 시 호출

정리 : WebSocket 연결은 handshake 가 완료되는 순간 시작되고 , 클라이언트 / 서버의 종료요청 , 네트워크문제 , 타임이ㅏ웃 등으로 closing handshake 가 완료되는 순간 종료된다 .
이 모든과정은 websokcet 프로토콜( RFC 6455) 에 의해 표준화되어있다 .

WebSocket은 서버와 클라이언트가 한 번 연결하면, 실시간으로 자유롭게 데이터를 주고받을 수 있어
채팅, 실시간 알림 등에는 필수적이고 , HTTP 는 요청-응답이 반복되는 구조라 실시간성이 떨어지며 , 서버푸시가 불가능하다 .
실시간성이 중요하다면 Wensocket , 단순 데이터 조회/등록은 HTTP 를 사용하는 이유이다 ..
***

ChatHandler와 RestController 는 각각 채팅에대해서 담당하는부분이다르다 .

그간 우리가 사용해왔던 방식에서는 HTTP 통신을통해서 서버와 클라이언트에서 클라이언트의 요청-> 서버의 응답 이런식으로  단방향 통신을통해 데이터를 저장하고 응답을 반환하는 로직이였으나 
WebSocket 통신을 사용하게된다면 통신이 끊어지지않는상태에서 서버와 클라이언트가 통신을하게된다 .
사용자간의 대화가 하나씩 생긴다면 ChatHandler에서 Json객체의 메세지를받아 DTO로변환 -> service 메서드를 호출하여 DB에 저장하게하는 실시간으로 주고받는 메세지를 담당하는 Contorller이고 
사용자의 대화방에대한 조회 , 사용자가 대화방에 들어갔을때 주고받았던 대화를 조회하는 HTTP 통신을 사용하는 Controller의 분리가 필요하다 .

여기서 websocket 통신을 사용했을때 끊어지지않는 통신에서 연결되어있는쪽은 user1과 user2 가 서로 대화를 하고있다고 가정했을때  user1- 서버 user2 -서버이고 ,  user1이 작성한메세지를 user2 는 
별도의 HTTP 통신을 이용하지않아도 실시간으로 서버에서 반환되는(DB에 저장되어있는 user1,user2 의메세지) 즉시 렌더링이 가능하다 .

stomp 를 사용하지않는다 . 우리는 1:1채팅만을 사용할것이기에 , 굳이 stomp 기반 웹소켓을 사용할 이유가없다 . 

1: 게시글의 채팅하기 버튼을 눌러 websocket 통신 시작 .
	postIdx와 채팅하기 버튼을 누른 빌리려는사람(borrower) 의 userId를 전송
	postIdx를 통해 lender(빌려주는사람 의 userEntity.idx)  @AuthenticationPrincipal String userId 매개변수를 통해서 인증객체(빌리려는사람 , borrower) 의  userId를통해 (userEntity.idx) 를 조회후
	두 사용자간의 채팅방이 있는없는지 검증 , 있다면 websokcet 연결 없다면 채팅방 생성로직 진행 후 webscoket 연결 
	
1 문제점 : webSocket 연결시에는 일반 http 요청과달리 spring security의 필터체인을 그대로 사용할수 없기에 헤더에 포함된 accessToken 으로 인증객체를 추출하려면 별도의 인증처리로직이 필요하다 .
1 해결방법 : HandshakeHandler 를 커스텀해서 token을 추출 후 인증 ,인증객체 생성(Authentication) , 인증사용자객체(Principal) 반환 후 Spring 이 인증객체를 세션에 저장한다 .



2.webSokcet 통신이 시작된후 첫메세지에서 채팅방에 세션을 추가한다 . 

WebSocket 통신 시작 후 첫 메시지 처리 및 텍스트 메시지 주고받기
문제점
WebSocket 연결이 수립된 직후에는 클라이언트가 바로 메시지를 보낼 수 있지만,
채팅방에 세션이 등록되어 있지 않으므로,
첫 메시지에서 채팅방 정보와 인증 정보를 기반으로 세션을 추가해야 한다.

메시지 핸들러에서 메시지를 파싱하고,
채팅방에 세션을 추가한 뒤,
이후부터는 해당 채팅방에 연결된 세션에만 메시지를 브로드캐스트해야 한다.

채팅방별 세션 관리를 위해 서버 메모리에 채팅방 ID를 키로,
세션 리스트(Set<WebSocketSession>)를 값으로 저장해야 한다.

해결방법
첫 메시지에서 채팅방 정보 및 인증 정보 추출

클라이언트가 보낸 첫 메시지(예: JSON)에서
postIdx, senderId, receiverId 등을 파싱한다.

핸드셰이크 핸들러에서 이미 인증 객체가 세션에 저장되어 있으므로,
session.getPrincipal()로 발신자(borrower) 정보를 얻을 수 있다.

채팅방 조회/생성

postIdx와 사용자 정보로 채팅방을 조회하거나,
없으면 새로 생성한다.

채팅방에 세션 추가

서버 메모리(ConcurrentHashMap<Long, Set<WebSocketSession>>)에
채팅방 ID를 키로, 해당 세션을 값으로 추가한다.

메시지 저장 및 브로드캐스트

메시지를 DB에 저장하고,
해당 채팅방에 연결된 모든 세션(본인 제외)에 메시지를 브로드캐스트한다.



1. 클라이언트가 WebSocket 연결 요청
클라이언트가 /chat 엔드포인트로 WebSocket 연결 요청을 보냅니다.

요청 헤더에 accessToken(JWT 등)을 포함시킵니다.

2. 핸드셰이크 핸들러(HandshakeHandler)에서 인증/인가 처리
WebSocketConfig에서 등록한 setHandshakeHandler()가 동작합니다.

핸드셰이크 핸들러(예: CustomHandshakeHandler)는

JWT를 추출 및 검증하고,

인증에 성공하면 Principal 객체를 생성해 WebSocket 세션에 저장합니다.

인증에 실패하면 연결이 거부됩니다.

3. WebSocket 연결 성공 및 세션 생성
핸드셰이크가 성공하면, WebSocket 연결이 맺어집니다.

세션에 인증 정보(Principal)가 저장되어,
이후 메시지 핸들러에서 session.getPrincipal()로 사용자 정보를 꺼낼 수 있습니다.

4. 클라이언트가 최초 메시지 전송
연결이 성공하면, 클라이언트가 메시지를 보냅니다.

WebSocket 핸들러(예: ChatHandler)의 handleTextMessage()가 호출됩니다.

핸들러에서 비즈니스 로직(메시지 저장, 실시간 전송 등)을 호출합니다.

예: chatService.saveAndSendMessage() 호출

메시지가 DB에 저장되고, 같은 채팅방의 다른 사용자에게 실시간으로 전송됩니다.

5. 양방향 통신 시작
메시지가 실시간으로 양방향으로 주고받아집니다.

각 메시지마다 WebSocket 세션에 저장된 인증 정보를 활용할 수 있습니다.


동작방식 요약 

단계				담당 클래스/메서드		주요 동작 내용
WebSocket 연결 요청		클라이언트		/chat 엔드포인트, accessToken 포함
인증/인가 처리			핸드셰이크 핸들러		JWT 검증, Principal 생성 및 세션 저장
연결 성공				서버, Spring WebSocket	WebSocket 세션 생성, 인증 정보 저장 //// 여기까지 
최초 메시지 전송			ChatHandler		메시지 저장, 실시간 전송
양방향 통신			ChatHandler, ChatService	메시지 실시간 송수신, 세션의 Principal로 사용자 식별



react 클라이언트와 채팅API 연동 .
 
1: 해당 게시물의 채팅하기 버튼.  ( 해당 게시물이 내가 작성한게시물일때는 채팅하기 대신 수정하는기능이나 채팅하기 버튼이 보이지않아야한다 .)
 채팅하기버튼을 눌렀을때는 navigate(chatRoom) 해당 사용자와의 채팅방으로 이동과 동시에 ws:localhost:9090/chat 에 요청을 해야한다 . 
최초로는 http 로 시작하지만 , Upgarde: websocket 헤더를 포함하여 webSocket 프로토콜로 전환(업그레이드) 하는 방식이다 .
브라우저의 webSokcet API 가 자동으로 이 모든과정을 처리해준다 . 즉 개발자가 직접헤더를 추가하거나 업그레이드 과정을 구현할 필요없이 
, 단순히 new Websocket()만 호출하면된다 .  
하지만 webSocketAPI 를 사용하게되는경우  헤더에 토큰을 직접적으로 추가할수없다 , 
서브 프로토콜 , 쿠키 , 첫메세지 중 하나로 토큰을 전달해야한다 . 

우리는 서브프로토콜에 프로토콜이름을 명시하는 용도가아닌 accessToken 변수를 담아서 sec-WebSocket-Protocol 헤더 값에 토큰을 직접 넣어서 보내는 방법을 사용한다 .
webSocket에 대해 무지했기떄문에 accessToken을 어떻게 넘겨야되는지 몰랐기때문에 일반적이진않지만 임시방편으로 서브프로토콜을 사용하여 accessToken을 명시해서 보내도록한다 .
서버에서는 항상 sec-WebSocket-Protocol 명시된 값을 token으로 받을수있게끔 작성한다 .

클라이언트 : 채팅버튼클릭이벤트(토큰,userId 전달) -> HTTP GET 요청으로 채팅방이 있는경우 채팅방정보와 채팅방 내용 얻기 ->  웹소켓 연결 함수호출 -> 연결 성공 시 채팅방 이동 




채팅하기 버튼을 눌렀을때 -> navigate(http://localhost:3000/chatRoom) 으로 이동이되면서 
webSokcet연결요청 및 내accessToken과 채팅하기버튼이 있던 게시물에있는 userId 를 매개변수로 http get요청을하여 http::localhost:3000/chatRoom 스크린에 get요청을통해 방이있다면 이전의 대화내용을 넣고
없다면 아무것도없는 빈채팅방을 렌더링한다

클라이언트는 채팅하기 버튼에 두가지함수가 필요하다 .
1 : 웹소켓을 연결하는 함수 
2 : http get 요청으로 채팅방과 채팅내용을 얻는 함수 .

진짜 최종정리 

채팅하기 버튼을 클릭함 - >  http://localhost9090/chat 엔드포인트에 http get 요청을통해서 채팅방이 없으면 채팅방을 만드는로직을 
채팅방이 있으면 chatRoomDTO와 그채팅방의 chattingMessageDTO를 반환하고  // 여기까지 구현완료 .
chatRoomDTO.roomId를통해서 ws 요청을보낸다 . 
get 요청을통해 무조건 roomId 를 받을수있다 . roomId를 통한 ws 연결 


연결후에 textmessage 보내보기 

**차후에 chatRoomEntity에 ChatMessage가 일정시간동안 추가되지않는다면 , chatRoom을 삭제하는 로직을 구현한다 .** (스케쥴러 사용 ) 
 // 0616 새벽까지 할일 .










 