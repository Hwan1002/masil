


로그아웃시 main 혹은 로그인페이지로 redirect 
웹페이를 닫았을경우 appllication 에서 쿠키에저장되어있는 refreshToken을 삭제되야한다 .
다시 웹페이지를 찾았을경우에 로그인이되어있는것을 방지해야한다 . // 쿠키의 maxAge(-1) (세션쿠키로 변경으로 해결  )

게시글 작성 컴포넌트에 위치를 갖게끔 
유저위치와 게시글 대여위치를 지정할수있게끔. 
유저위치는 마이페이지 , 혹은메인페이지 어디에서할지 지정해야하고 
게시글위치는 게시글을 작성할때에 희망하는 거래장소를 설정할수 있게끔 만든다 .
게시글 post API 수정 -> 게시글 Modify API 수정 = 위치 지정 , LocationButton , LocationPicker 에있는 기능들을 그대로 좌표전송 해줘야함 .
게시글 entity , DTO 에 lat , lng , address 필드추가 및 외부 API 호출로 인한 reverseGeoCoding 및 법정동코드 -> address반환로직 추가 .
로그인시 address 반환해주기 .
수정도 마찬가지 .
여유있을시에 반경만들기 해도되고 .
location Button , location Picker 컴포넌트에 API.post가아닌 axios.post로 바꿔야함 , 유저 인증객체를 보내는로직이아닌 그냥 단순 좌표가공만해서 넘겨줘야함 , 넘겨받은코드를 userDB에 연결해줘야함 .
// 완료 


일반 회원가입의 로직에서 signup 

시나리오 1: 실시간 사용자위치지정 버튼을 클릭해서 위치를 지정함
locationController 의 localhost:9090/setLocation 엔드포인트 로 요청 lat,lng 전달 locationService의 getLocation(lat,lng) 메서드 호출
locationService lat,lng 를  KakaoGeocodingService 클래스의 getBcode 를통해 bCode얻기 -> Bcode를통하여 법정동 
읍면동 명 추출 ->   locationDTO 의 lat,lng,address 속성의 값 세팅후 객체반환


시나리오 2: 검색을통한 위치얻기 방법을 사용하여 위치를 지정함 
locationController 의 localhost:9090/setLocation 엔드포인트 로 요청 lat,lng 전달 locationService의 getLocation(lat,lng) 메서드 호출
locationService lat,lng 를  KakaoGeocodingService 클래스의 getBcode 를통해 bCode얻기 -> Bcode를통하여 법정동 
읍면동 명 추출 ->   locationDTO 의 lat,lng,address 속성의 값 세팅후 객체반환


location 객체생성 , contextAPI 사용 .

location  = {
lat : "" ,
lng: "" ,
address : "" 	
}

lat , lng를 전송 -> lat,lng -> 법정동코드 변환 -> 법정동코드 -> address변환 -> 
userRepository.save(user) ; 

// 게시글 , 회원가입시 위치 완료 .


*** 소셜로그인시 유저가 위치를갖고있는지 검증하는 로직 필요함 , 그리고 소셜로그인시에 회원


게시글 수정 ,삭제,  로직에대해서 유저와 게시글과의 관계 검토해야함 .(권한)
내가작성하지 않은게시물이 수정되는 오류가 나올수도있음 . // 해결 (예외처리와 게시글의 작성자와 인증객체의 비교로직 추가)

내가작성한 게시물보기 API 추가개발 필요함.  // 해결
게시글 삭제시 사진삭제로직도 추가 .// 해결 







회원가입시 위치지정추가  지역설정하는 컴포넌트를 
소셜로그인시 위치지정 추가 . 환영합니다 modal 확인버튼클릭시 Address 를 가지고있지 않은유저면 지역을 설정하게끔해야한다.

환석 : 수정페이지 로직구현 및 삭제버튼 수정페이지안에 넣어야함 .작성자만 수정버튼이 나와야함 . 
postRegist 부분에 게시글 위치설정추가 locationPicker , LocationButton 컴포넌트에있는 코드랑 아예똑같아도 되는데 요청 엔드포인트만 다름.


동욱 : 비밀번호 변경부 수정 . / 위치설정버튼 LocationPicker, LocationButton 컴포넌트사용해서 user위치 설정하는부분 회원가입 

소셜로그인시 위치지정 추가 . 환영합니다 modal 확인버튼클릭시 Address 를 가지고있지 않은유저면 지역을 설정하게끔해야한다.



로그인 반환값 : status : 200 , 
	value : "환영합니다"
	address : "동" or null 


if(address ==null) {
	위치설정 로직
}else{
	로그인 성공로직 .
}

일반사용자는 회원가입시에 필수적으로 위치를 설정하게 되어있다 .

social로그인사용자





동욱 : 위치컴포넌트 UI 수정 , 회원가입 위치저장 , input readOnly address 박기 . , 마이페이지  : 내게시물보기 및 회원정보수정 ,





20250508 

1 : 로그인시에 반환되는 responseDTO 에 userId 추가하기 . // 했음

2 : userId 저장하는 로직구현되면 socialLogin쪽도 동일한 로직으로 userId 저장할수있게 구현하기.

3 : 소셜로그인 사용자가 최초로 로그인 (회원가입 , 로그인이 동시에 이루어짐 ) 했을경우에는 위치를 설정하게끔 하는 로직이필요함 , 페이지를 이동시켜서 할것인지 버튼만 누르게할것인지 정해야함 (동욱이형이랑 같이)

4 : 마이페이지에서 회원정보 수정 / 내게시물보기 두개 나눠야함 . 회원정보 수정에는 위치변경하는거 추가해야함. (동욱이형이랑 같이)





일반로그인 사용자 :
회원가입시 현재위치 , 혹은 사용자가 직접 지정한 위치 두개중 하나를 필수적으로 등록하고 회원가입을 하게됨 .
** 일반로그인을 진행한 사용자는 무조건 user.address가 있음 
그렇기때문에 로그인을했을떄 위치가 없다고 위치를 지정해달라는 안내가 필요없음 .

소셜로그인 사용자 :
회원가입 - 로그인을 우리 프론트딴에서 만들어놓은 로직을 통한 회원가입/로그인이 아니기때문에 위치를 지정하지못함 .
소셜로그인이 성공적으로 완료되었을때 로그인 성공메세지, status 가 반환됨 . 추가로 hasAddress , userId 를 같이 반환해줘야함  
프론트는 받은 userId를 localStorage에 저장해줘야하며 ( 내가할거 )

소셜로그인으로 로그인을 성공했을때 반환받은 hasAddress의값이 false인경우 위치를 설정할수있는 
화면을 렌더링해줘야함 . 이걸 어떻게할지 상의가필요함 .
만약hasAddress가 true 인 경우는 로그인성공시와 동일하게 진행해야함 .



근처 게시물 API 개발

- 로그인 사용자가 아닌경우 401반환 리액트에서는 로그인사용자에게만 근처게시물보기버튼을 활성화 하거나 
근처게시물보기버튼을 눌렀을때 로그인사용자가 아닌경우 로그인페이지로 리다이렉트

- 로그인 사용자인경우 accessToken만 포함해서 get요청  -> 
서버 : 시큐리티 컨텍스트홀더에 저장되어있는 userId 추출 후 user객체 꺼내옴
user객체속 lat, lng 추출 후 postRepository에서 lat,lng를 매개변수로 받아 반경을 계산 , 반경안에있는 게시물을 반환하는 쿼리작성
반환받은 List<PostEntity> -> List<PostDTO> 변경 후 클라이언트에 반환  

(MySQL 의 point 타입을 사용하는방법이있지만 이미 entity설계가 끝나있는상황이니 point 는 다음에 사용.)



좋아요기능 개발
- entity , dto , repository , service , controller 

게시글속에 찜하기같은 버튼이있음 , 
이버튼은 useEffect를통해서 wished라는 변수에 게시물이 찜되어있는지 안되어있는지에대해 설정 
 게시글이 최초 렌더링될때 , 의존배열에 wished를 넣어 wished의 값이 바뀌거나 최초렌더링시에 찜버튼의 하트 속을 채우거나 비어있거나 둘중하나의 상태로만드려고한다 . 
위의 글은 적합한가 ?

wished 토글버튼 -> 

useEffect(() => {
  // 게시글이 최초 렌더링될 때, 또는 wished가 바뀔 때 실행
  // (최초 렌더링 시에만 서버 조회를 원한다면 의존성 배열을 [postId]로!)
  fetch(`/api/favorites/check?postId=${postId}&userId=${userId}`)
    .then(res => res.json())
    .then(data => setWished(data.isWished));
}, [postId, userId]); // wished를 의존성 배열에 넣으면, wished가 바뀔 때마다 다시 실행됨

// 하트 버튼 클릭 핸들러
const handleWishClick = () => {
  if (wished) {
    // 찜 해제 API 호출
    setWished(false);
  } else {
    // 찜 추가 API 호출
    setWished(true);
  }
};

return (
  <button onClick={handleWishClick}>
    {wished ? <FilledHeartIcon /> : <EmptyHeartIcon />}
  </button>
);



서버에서 받아야할것 .

사용자가 빈하트를 눌렀을때의 시나리오

매개변수로 무엇을 받을것인지 
postIdx ,userIdx 

accessToken (컨텍스트에 저장된 userId 를통해서 사용자확인) 

userIdx 와 로그인되어있는 userId 비교로직 


사용자가 하트를눌렀을때의 시나리오 






채팅API 개발






 
	



